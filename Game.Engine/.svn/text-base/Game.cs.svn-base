using System;
using System.Collections.Generic;
using System.Linq;
using System.Timers;
using Wintellect.PowerCollections;

namespace Game.Engine
{
    public class Game
    {
        private const uint CELL_MASK = 0x11000000;
        private const uint OBJ_MASK = 0x00111100;

        private const uint CELL_MEAS = 20;

        readonly uint[,] _map;
        Rect _curRect;

        Dictionary< uint, Cell> _cellSamples;
        Dictionary< uint, FixedObject > _objectSamples;

        private LoadSaveManager _loadSaveManager;

        private readonly Timer _timer;

        private readonly Hero _hero;

        private readonly IDrawer _drawer;


        public Game( IDrawer drawer, uint width, uint height )
        {
            _curRect.Width = width;
            _curRect.Height = height;
            _map = new uint[_curRect.Width / CELL_MEAS, _curRect.Height / CELL_MEAS];

            _loadSaveManager = new LoadSaveManager();
            _loadSaveManager.LoadSnapshot( _map );

            _objectSamples = new Dictionary<uint, FixedObject>();
            _objectSamples[0x00000000] = new FixedObject(); // automize
            _objectSamples[0x00000100] = new Tree(); // automize

            _timer = new Timer(100);
            _timer.Enabled = true;
            _timer.Elapsed += OnTimedEvent;

            _hero = new Hero();

            _drawer = drawer;
        }


        private void LoadSettings()
        {
            Properties.Settings.Default.Reload();
        }

        private void SaveSettings()
        {
            Properties.Settings.Default.Save();
        }

        private void OnTimedEvent(object source, ElapsedEventArgs e)
        {
            _hero.State.Act();
        }

        public void LClick( Point destination )
        {
            MoveToDest(destination);
        }

        public void MoveToDest( Point destination )
        {
            _hero.StartMove( destination, GetEasiestWay( _hero.Position, destination ) );
        }

        class WayPoint : IComparable<WayPoint>
        {
            public WayPoint(WayPoint parent, Point point, int cost, int evristic )
            {
                Point = new Point( point );
                Cost = cost;
                Parent = parent;
                IsProcessed = false;
                Evristic = evristic;
            }

            public WayPoint Parent { get; set; }

            public Point Point { get; set; }
            public bool IsProcessed { get; set; }
            public int Cost { get; set; }
            public int Evristic { get; private set;  }

          //  protected WayPoint()

            public int CompareTo( WayPoint other )
            {
                if (ReferenceEquals(this, other)) return 0;

                return Cost + Evristic - other.Cost - other.Evristic;
            }
        }

        public Stack<Point> GetEasiestWay(Point start, Point dest)
        {
            Stack<Point> resultStack = new Stack<Point>();
            resultStack.Push( dest );

            OrderedBag<WayPoint> workPoints = new OrderedBag<WayPoint>();
         //   SortedSet<WayPoint> workPoints = new SortedSet<WayPoint>();
            Dictionary<Point, WayPoint> processedPoints = new Dictionary<Point, WayPoint>();

            Point startP = new Point( start.X/CELL_MEAS, start.Y/CELL_MEAS );
            Point destP = new Point( dest.X/CELL_MEAS, dest.Y/CELL_MEAS );

            if ( startP.Equals( destP ) )
                return resultStack;

            WayPoint startWayP = new WayPoint( null, startP, 0, 0 );
            workPoints.Add(startWayP);
            processedPoints.Add(startWayP.Point, startWayP);
            WayPoint current = null;

            while( workPoints.Count>0 && !destP.Equals( workPoints.First().Point ) )
            {
                Point temp = new Point( workPoints.First().Point );
                int i, j;

                current = workPoints.First();

                for (i = (int)current.Point.X - 1 > 0 ? 0 : 1, temp.X = current.Point.X + (uint)i - 1; i <= 2 && temp.X < _map.GetLength(0); i++, temp.X++)
                {
                    for (j = (int)current.Point.Y - 1 > 0 ? 0 : 1, temp.Y = current.Point.Y + (uint)j - 1; j <= 2 && temp.Y < _map.GetLength(1); j++, temp.Y++)
                    {
                        if( i == 1 && j == 1  )
                            continue;

                        if (!_objectSamples[_map[temp.X, temp.Y] & OBJ_MASK].IsPassable)
                            continue;

                        int tmpCost = ((i + j) % 2 == 0 ? 14 : 10) + current.Cost; // если обрабатываемая клетка лежит по диагонали к родительской - прибавляем 14(приближ. корень2), если нет - 10

                        if( processedPoints.ContainsKey( temp ) )
                        {
                            if( processedPoints[temp].IsProcessed )
                                continue;
                            
                            if( tmpCost > processedPoints[temp].Cost )
                            {
                                processedPoints[temp].Cost = tmpCost;
                                processedPoints[temp].Parent = current;
                            }
                        }
                        else
                        {
                            int distX = (int)Math.Abs((int)destP.X - (int)temp.X);
                            int distY = (int)Math.Abs((int)destP.Y - (int)temp.Y);
                            int tmpEvristic = (int)(distX > distY ? distY*14 + 10*(distX - distY) : distX*14 + 10*(distY - distX));
                            WayPoint next = new WayPoint(current, temp, tmpCost, tmpEvristic);

                            workPoints.Add(next);
                            processedPoints.Add( next.Point, next );
                        }
                    }
                }

                current.IsProcessed = true;

                workPoints.RemoveFirst();
            }

            if( workPoints.Count > 0 )
            {
                Point stackPoint;
                while( current != null )
                {
                    stackPoint = new Point(current.Point.X * CELL_MEAS  + CELL_MEAS/2, current.Point.Y * CELL_MEAS  + CELL_MEAS/2);
                    resultStack.Push( stackPoint );
                    current = current.Parent;
                }
            }

            return resultStack;
        }

        public void DrawChanges()
        {
            _drawer.Clear();
            for (int i = 0; i < _map.GetLength(0); i++)
            {
                for (int j = 0; j < _map.GetLength(1); j++)
                {
                    _drawer.DrawObject(_objectSamples[_map[i, j] & OBJ_MASK].Id, i * CELL_MEAS, j * CELL_MEAS);
                }
            }

            _drawer.DrawHero( _hero.Position, _hero.Angle, _hero.PointList );
        }

    }
}
